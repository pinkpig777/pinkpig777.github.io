import { promises as fs } from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import matter from 'gray-matter';
import { unified } from 'unified';
import remarkParse from 'remark-parse';
import remarkGfm from 'remark-gfm';
import remarkMath from 'remark-math';
import remarkRehype from 'remark-rehype';
import rehypeKatex from 'rehype-katex';
import rehypeHighlight from 'rehype-highlight';
import rehypeStringify from 'rehype-stringify';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootDir = path.resolve(__dirname, '..');
const contentDir = path.join(rootDir, 'src', 'content', 'blog');
const outputDir = path.join(rootDir, 'src', 'generated');
const outputFile = path.join(outputDir, 'blog.ts');

const markdownProcessor = unified()
  .use(remarkParse)
  .use(remarkGfm)
  .use(remarkMath)
  .use(remarkRehype, { allowDangerousHtml: true })
  .use(rehypeKatex)
  .use(rehypeHighlight, { detect: true, ignoreMissing: true })
  .use(rehypeStringify, { allowDangerousHtml: true });

const normalizeDate = (value) => {
  if (!value) return '';
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) return String(value);
  return date.toISOString().slice(0, 10);
};

const normalizeTags = (value) => {
  if (!value) return [];
  if (Array.isArray(value)) return value.map((tag) => String(tag));
  return [String(value)];
};

const buildSummary = (content) => {
  const plainText = content
    .replace(/```[\s\S]*?```/g, ' ')
    .replace(/`[^`]*`/g, ' ')
    .replace(/[#>*_\-]/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
  if (!plainText) return '';
  const short = plainText.slice(0, 180);
  return plainText.length > 180 ? `${short}â€¦` : short;
};

const sortByDateDesc = (a, b) => {
  const aTime = new Date(a.date).getTime();
  const bTime = new Date(b.date).getTime();
  if (Number.isNaN(aTime) && Number.isNaN(bTime)) return 0;
  if (Number.isNaN(aTime)) return 1;
  if (Number.isNaN(bTime)) return -1;
  return bTime - aTime;
};

const ensureDir = async (dir) => {
  await fs.mkdir(dir, { recursive: true });
};

const toSlug = (filename, data) => {
  if (data && data.slug) return String(data.slug);
  return filename.replace(/\.md$/, '');
};

const buildBlog = async () => {
  await ensureDir(contentDir);
  await ensureDir(outputDir);

  const entries = await fs.readdir(contentDir, { withFileTypes: true });
  const files = entries
    .filter((entry) => entry.isFile() && entry.name.endsWith('.md'))
    .map((entry) => entry.name);

  const posts = [];

  for (const filename of files) {
    const fullPath = path.join(contentDir, filename);
    const raw = await fs.readFile(fullPath, 'utf8');
    const { data, content } = matter(raw);

    if (data.draft === true) {
      continue;
    }

    const slug = toSlug(filename, data);
    const title = data.title ? String(data.title) : slug.replace(/[-_]/g, ' ');
    const date = normalizeDate(data.date);
    const tags = normalizeTags(data.tags);
    const summary = data.summary ? String(data.summary) : buildSummary(content);
    const html = String(await markdownProcessor.process(content));

    posts.push({
      slug,
      title,
      date,
      summary,
      tags,
      html,
    });
  }

  posts.sort(sortByDateDesc);

  const postMap = Object.fromEntries(posts.map((post) => [post.slug, post]));

  const output = `/* eslint-disable */\n/* This file is auto-generated by scripts/build-blog.mjs */\n\nexport type BlogPost = {\n  slug: string;\n  title: string;\n  date: string;\n  summary: string;\n  tags: string[];\n  html: string;\n};\n\nexport const blogPosts: BlogPost[] = ${JSON.stringify(posts, null, 2)};\n\nexport const blogPostBySlug: Record<string, BlogPost> = ${JSON.stringify(postMap, null, 2)};\n`;

  await fs.writeFile(outputFile, output, 'utf8');
  console.log(`Generated ${outputFile} (${posts.length} posts)`);
};

buildBlog().catch((error) => {
  console.error(error);
  process.exit(1);
});
